#!/bin/bash
#
# Copyright (C) 2021 Stonyx
# http://www.stonyx.com
#
# This script is free software. You can redistribute it and/or modify it under the terms of the GNU
# General Public License Version 3 (or at your option any later version) as published by The Free
# Software Foundation.
#
# This script is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without
# even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
#
# If you did not received a copy of the GNU General Public License along with this script see
# http://www.gnu.org/copyleft/gpl.html or write to The Free Software Foundation, 675 Mass Ave,
# Cambridge, MA 02139, USA.

# Function called to check if a needed command is available
function check_if_available()
{
  if ! command -v "$1" > /dev/null
  then
    echo "Command $1 is required but is not available."
    exit 1
  fi
}

# Check if the needed commands are available
check_if_available "dd"
check_if_available "xdelta3"

# Declare all options variables
declare -a inputs
declare backup
declare restore
declare output
declare dd_options
declare xdelta_options
declare xz_options
declare -i use_compression=0
declare -i quiet_mode=0

# Get the options
while getopts "i:f:b:r:o:d:l:cx:qh" option
do
  case $option in
    i)
      inputs+=("$OPTARG")
      ;;
    f)
      # Read the file paths into an array
      declare -a paths
      mapfile -t paths < "$OPTARG"

      # Get the dependees file path (without relying on dirname command)
      declare dependees_file_path
      if [[ "$OPTARG" != *"/"* ]]
      then
        dependees_file_path="."
      else
        dependees_file_path="${OPTARG%/*}"
      fi

      # Loop through the file paths
      for i in "${!paths[@]}"
      do
        # Check if the path is relative
        if [[ "${paths[$i]}" != "/"* ]]
        then
          # Prepend the dependees file path to the path
          paths[$i]="$dependees_file_path/${paths[$i]}"
        fi
      done

      # Append the file paths to the inputs array
      inputs+=("${paths[@]}")
      ;;
    b)
      backup="$OPTARG"
      ;;
    r)
      restore="$OPTARG"
      ;;
    o)
      output="$OPTARG"
      ;;
    d)
      dd_options=" $OPTARG"
      ;;
    l)
      xdelta_options=" $OPTARG"
      ;;
    c)
      # Check if xz command is available
      check_if_available "xz"

      # Set the compression flag
      use_compression=1
      ;;
    x)
      xz_options=" $OPTARG"
      ;;
    q)
      quiet_mode=1
      ;;
    h)
      echo "Usage: ddinc [-i file] [-f file] (-b file_or_device | -r file) [-o file_or_device]" \
           "[-d dd_options] [-l xdelta3 options] [-c] [-x xz_options] [-q]"
      echo
      echo "-i   dependee input file (can be specified multiple times)"
      echo "-f   file containing list of dependee input files (using absolute paths or paths" \
           "relative to this file) (can be specified multiple times)"
      echo "-b   file or device to backup"
      echo "-r   file to restore"
      echo "-o   output file or device (uses stdout if not specified)"
      echo "-d   string containing options passed to dd for reading in backup mode and writing" \
           "in restore mode"
      echo "-l   string containing options passed to xdelta3 for encoding"
      echo "-c   use compression"
      echo "-x   string containing options passed to xz for compression"
      echo "-q   quiet mode"
      echo "-h   show help"
      echo
      echo "Backup examples"
      echo "ddinc -i ../january/sda.dd.xz -i ../february/sda.dd.xdelta.xz" \
           "-i ../march/sda.dd.xdelta.xz -b /dev/sda -o sda.dd.xdelta.xz"
      echo "ddinc -f sda.dd.dependees -b /dev/sda -o sda.dd.xdelta.xz"
      echo
      echo "Restore examples"
      echo "ddinc -i ../january/sda.dd.xz -i ../february/sda.dd.xdelta.xz" \
           "-i ../march/sda.dd.xdelta.xz -r sda.dd.xdelta.xz -o /dev/sda"
      echo "ddinc -f sda.dd.dependees -r sda.dd.xdelta.xz -o /dev/sda"

      exit 0
      ;;
  esac
done
shift $((OPTIND - 1))

# Make sure backup or restore was specified
if [[ -z $backup ]] && [[ -z $restore ]]
then
  echo "No backup file or restore file specified.  See help (-h) for details."
  exit 1
fi

# Make sure all input files exist and are not directories
for input in "${inputs[@]}"
do
  if [[ ! -e "$input" ]] || [[ -d "$input" ]]
  then
    echo "Input file $input does not exist."
    exit 1
  fi
done

# Create a function called to build the source portion of the command
function build_source_portion()
{
  # Save passed in variables
  local inputs=("${!1}")
  local use_compression=$2

  # Declare local variables
  local command

  # Loop through the inputs array and build the xdelta3 source portion of the command
  for i in "${!inputs[@]}"
  do
    # Check if this is the first element in the array
    if [[ $i -eq 0 ]]
    then
      # Check if compression is disabled/enabled and build the source portion for this full input
      # file
      if [[ $use_compression -eq 0 ]]
      then
        command="\"${inputs[$i]}\""
      else
        command="<(xz -d -c \"${inputs[$i]}\")"
      fi
    else
      # Build the source portion for this incremental input file
      command="<(xdelta3 -d -c -s $command"

      # Check if compression is disabled/enabled and continue building the source portion
      if [[ $use_compression -eq 0 ]]
      then
        command="$command \"${inputs[$i]}\""
      else
        command="$command <(xz -d -c \"${inputs[$i]}\")"
      fi

      # Finish building the source portion
      command="$command)"
    fi
  done

  # Return the source portion of the command
  echo $command
}

# Create a function called to build a full backup command
function build_full_backup_command()
{
  # Save passed in variables
  local backup=$1
  local ouput=$2
  local dd_options=$3
  local use_compression=$4
  local xz_options=$5

  # Build the command for a full backup
  local command="dd if=\"$backup\"$dd_options"

  # Check if compression is enabled and continue building the command
  if [[ $use_compression -eq 1 ]]
  then
    command="$command | xz -z -c$xz_options"
  fi

  # Check if an output was specified and finish building the command
  if [[ -n $output ]]
  then
    command="$command > \"$output\""
  fi

  # Return the command for a full backup
  echo $command
}

# Create a function called to build an incremental backup command
function build_incremental_backup_command()
{
  # Save passed in variables
  local inputs=("${!1}")
  local backup=$2
  local output=$3
  local dd_options=$4
  local xdelta_options=$5
  local use_compression=$6
  local xz_options=$7

  # Call the build_source_portion function to build the source portion of the command
  local command=$(build_source_portion inputs[@] $use_compression)

  # Build the command for an incremental backup
  command="xdelta3 -e -c -s $command$xdelta_options <(dd if=\"$backup\"$dd_options)"

  # Check if compression is enabled and continue building the command
  if [[ $use_compression -eq 1 ]]
  then
    command="$command | xz -z -c$xz_options"
  fi

  # Check if an output was specified and finish building the command
  if [[ -n $output ]]
  then
    command="$command > \"$output\""
  fi

  # Return the command for an incremental backup
  echo $command
}

# Create a function called to build a full restore command
function build_full_restore_command()
{
  # Save passed in variables
  local restore=$1
  local output=$2
  local dd_options=$3
  local use_compression=$4

  # Declare local variables
  local command

  # Check if compression is disabled/enabled and build the command for a full restore
  if [[ $use_compression -eq 0 ]]
  then
    command="dd"
  else
    command="xz -d -c \"$restore\" | dd"
  fi

  # Check if an output was specified and continue building the command
  if [[ -n $output ]]
  then
    command="$command of=\"$output\""
  fi

  # Continue building the command
  command="$command$dd_options"

  # Check if compression is disabled and finish building the command
  if [[ $use_compression -eq 0 ]]
  then
    command="$command < \"$restore\""
  fi

  # Return the command for a full restore
  echo $command
}

# Create a function called to build an incremental restore command
function build_incremental_restore_command()
{
  # Save the passed in variables
  local inputs=("${!1}")
  local restore=$2
  local output=$3
  local dd_options=$4
  local use_compression=$5

  # Call the build_source_portion function to build the source portion of the command
  local command=$(build_source_portion inputs[@] $use_compression)

  # Build the command for an incremental restore
  command="xdelta3 -d -c -s $command"

  # Check if compression is disabled/enabled and continue building the command
  if [[ $use_compression -eq 0 ]]
  then
    command="$command < \"$restore\" | dd"
  else
    command="$command <(xz -d -c \"$restore\") | dd"
  fi

  # Check if an output is specified and continue building the command
  if [[ -n $output ]]
  then
    command="$command of=\"$output\""
  fi

  # Finish building the command
  command="$command$dd_options"

  # Return the command for an incremental restore
  echo $command
}

# Check if a backup file was specified
if [[ -n $backup ]]
then
  # Check if input files were specified and call the correct function to build the command
  if [[ ${#inputs[@]} -eq 0 ]]
  then
    command=$(build_full_backup_command "$backup" "$output" "$dd_options" "$use_compression" \
      "$xz_options")
  else
    command=$(build_incremental_backup_command inputs[@] "$backup" "$output" "$dd_options" \
      "$xdelta_options" "$use_compression" "$xz_options")
  fi
else
  # Check if input files were specified and call the correct function to build the command
  if [[ ${#inputs[@]} -eq 0 ]]
  then
    command=$(build_full_restore_command "$restore" "$output" "$dd_options" "$use_compression")
  else
    command=$(build_incremental_restore_command inputs[@] "$restore" "$output" "$dd_options" \
      "$use_compression")
  fi
fi

# Check if quite mode is disabled/enabled and run the command
if [[ $quiet_mode -eq 0 ]]
then
  echo "Command that will be run: $command" >&2
  read -p "Continue (Y/n)?" -n 1 -r
  if [[ -n $REPLY ]]
  then
    echo "" >&2
  fi
  if [[ -z $REPLY ]] || [[ $REPLY =~ ^[Yy]$ ]]
  then
    bash -c "$command"
    exit $?
  fi
else
  bash -c "$command"
  exit $?
fi
