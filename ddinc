#!/bin/bash
#
# Copyright (C) 2021 Stonyx
# http://www.stonyx.com
#
# This script is free software. You can redistribute it and/or modify it under the terms of the GNU
# General Public License Version 3 (or at your option any later version) as published by The Free
# Software Foundation.
#
# This script is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without
# even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
#
# If you did not received a copy of the GNU General Public License along with this script see
# http://www.gnu.org/copyleft/gpl.html or write to The Free Software Foundation, 675 Mass Ave,
# Cambridge, MA 02139, USA.

# Define sane values for all options
input=()
backup=""
restore=""
output=""
dd_options=""
xdelta_options=""
xz_options=""
use_compression=0
quiet_mode=0

# Get the options
while getopts "i:f:b:r:o:d:l:cx:qh" option
do
  case $option in
    i)
      input+=("$OPTARG")
      ;;
    f)
      # TODO: add to the input array content instead of replacing all content
      mapfile -t input < "$OPTARG"
      ;;
    b)
      backup="$OPTARG"
      ;;
    r)
      restore="$OPTARG"
      ;;
    o)
      output="$OPTARG"
      ;;
    d)
      dd_options=" $OPTARG"
      ;;
    l)
      xdelta_options=" $OPTARG"
      ;;
    c)
      use_compression=1
      ;;
    x)
      xz_options=" $OPTARG"
      ;;
    q)
      quiet_mode=1
      ;;
    h)
      echo "Usage: ddinc [-i file] [-f file] (-b file_or_device | -r file) [-o file_or_device]"\
           "[-d dd_options] [-l xdelta3 options] [-c] [-x xz_options] [-q]"
      echo
      echo "-i   dependee input file (can be specified multiple times)"
      echo "-f   text file containing list of dependee input files (can be specified multiple"\
           "times)"
      echo "-b   file or device to backup"
      echo "-r   file to restore"
      echo "-o   output file or device"
      echo "-d   string containing options passed to dd for reading in backup mode and writing"\
           "in restore mode"
      echo "-l   string containing options passed to xdelta3 for encoding"
      echo "-c   use compression"
      echo "-x   string containing options passed to xz for compression"
      echo "-q   quiet mode"
      echo "-h   show help"
      echo
      echo "Backup example"
      echo "ddinc -i ../January/sda.dd.xz -i ../February/sda.dd.xdelta.xz"\
           "-i ../March/sda.dd.xdelta.xz -b /dev/sda -o sda.dd.xdelta.xz"
      echo "ddinc -f sda.dd.dependees -b /dev/sda -o sda.dd.xdelta.xz"
      echo
      echo "Restore example"
      echo "ddinc -i ../January/sda.dd.xz -i ../February/sda.dd.xdelta.xz"\
           "-i ../March/sda.dd.xdelta.xz -r sda.dd.xdelta.xz -o /dev/sda"
      echo "ddinc -f sda.dd.dependees -r sda.dd.xdelta.xz -o /dev/sda"

      exit 0
      ;;
  esac
done
shift $((OPTIND - 1))

# Verify the options
if [[ -z $backup ]] && [[ -z $restore ]]
then
  echo "No backup file or restore file specified.  See help (-h) for details."
  exit 1
fi

# TODO: verify that all of the various files specified actually exist

# Create a function called to build the source portion of the command
function build_source_portion()
{
  # Save passed in variables
  local input=("${!1}")
  local use_compression=$2

  # Declare local variables
  local command=""

  # Loop through the input array and build the xdelta3 source portion of the command
  for i in ${!input[@]}
  do
    # Check if this is the first element in the array
    if [[ $i -eq 0 ]]
    then
      # Check if compression is disabled/enabled and build the source portion for this full input
      # file
      if [[ $use_compression -eq 0 ]]
      then
        command="${input[$i]}"
      else
        command="<(xz -d -c ${input[$i]})"
      fi
    else
      # Build the source portion for this incremental input file
      command="<(xdelta3 -d -c -s $command"

      # Check if compression is disabled/enabled and continue building the source portion
      if [[ $use_compression -eq 0 ]]
      then
        command="$command ${input[$i]}"
      else
        command="$command <(xz -d -c ${input[$i]})"
      fi

      # Finish building the source portion
      command="$command)"
    fi
  done

  # Return the source portion of the command
  echo $command
}

# Create a function called to build a full backup command
function build_full_backup_command()
{
  # Save passed in variables
  local backup=$1
  local ouput=$2
  local dd_options=$3
  local use_compression=$4
  local xz_options=$5

  # Build the command for a full backup
  local command="dd if=$backup$dd_options"

  # Check if compression is enabled and continue building the command
  if [[ $use_compression -eq 1 ]]
  then
    command="$command | xz -z -c$xz_options"
  fi

  # Check if an output was specified and finish building the command
  if [[ -n $output ]]
  then
    command="$command > $output"
  fi

  # Return the command for a full backup
  echo $command
}

# Create a function called to build an incremental backup command
function build_incremental_backup_command()
{
  # Save passed in variables
  local input=("${!1}")
  local backup=$2
  local output=$3
  local dd_options=$4
  local xdelta_options=$5
  local use_compression=$6
  local xz_options=$7

  # Call the build_source_portion function to build the source portion of the command
  local command=$(build_source_portion input[@] $use_compression)

  # Build the command for an incremental backup
  command="xdelta3 -e -c -s $command$xdelta_options <(dd if=$backup$dd_options)"

  # Check if compression is enabled and continue building the command
  if [[ $use_compression -eq 1 ]]
  then
    command="$command | xz -z -c$xz_options"
  fi

  # Check if an output was specified and finish building the command
  if [[ -n $output ]]
  then
    command="$command > $output"
  fi

  # Return the command for an incremental backup
  echo $command
}

# Create a function called to build a full restore command
function build_full_restore_command()
{
  # Save passed in variables
  local restore=$1
  local output=$2
  local dd_options=$3
  local use_compression=$4

  # Declare local variables
  local command=""

  # Check if compression is disabled/enabled and build the command for a full restore
  if [[ $use_compression -eq 0 ]]
  then
    command="dd"
  else
    command="xz -d -c $restore | dd"
  fi

  # Check if an output was specified and continue building the command
  if [[ -n $output ]]
  then
    command="$command of=$output"
  fi

  # Continue building the command
  command="$command$dd_options"

  # Check if compression is disabled and finish building the command
  if [[ $use_compression -eq 0 ]]
  then
    command="$command < $restore"
  fi

  # Return the command for a full restore
  echo $command
}

# Create a function called to build an incremental restore command
function build_incremental_restore_command()
{
  # Save the passed in variables
  local input=("${!1}")
  local restore=$2
  local output=$3
  local dd_options=$4
  local use_compression=$5

  # Call the build_source_portion function to build the source portion of the command
  local command=$(build_source_portion input[@] $use_compression)

  # Build the command for an incremental restore
  command="xdelta3 -d -c -s $command"

  # Check if compression is disabled/enabled and continue building the command
  if [[ $use_compression -eq 0 ]]
  then
    command="$command < $restore | dd"
  else
    command="$command <(xz -d -c $restore) | dd"
  fi

  # Check if an output is specified and continue building the command
  if [[ -n $output ]]
  then
    command="$command of=$output"
  fi

  # Finish building the command
  command="$command$dd_options"

  # Return the command for an incremental restore
  echo $command
}

# Check if a backup file was specified
if [[ -n $backup ]]
then
  # Check if input files were specified and call the correct function to build the command
  if [[ ${#input[@]} -eq 0 ]]
  then
    command=$(build_full_backup_command "$backup" "$output" "$dd_options" "$use_compression" \
      "$xz_options")
  else
    command=$(build_incremental_backup_command input[@] "$backup" "$output" "$dd_options" \
      "$xdelta_options" "$use_compression" "$xz_options")
  fi
else
  # Check if input files were specified and call the correct function to build the command
  if [[ ${#input[@]} -eq 0 ]]
  then
    command=$(build_full_restore_command "$restore" "$output" "$dd_options" "$use_compression")
  else
    command=$(build_incremental_restore_command input[@] "$restore" "$output" "$dd_options" \
      "$use_compression")
  fi
fi

# Check if quite mode is disabled/enabled and run the command
if [[ $quiet_mode -eq 0 ]]
then
  echo "Command that will be run: $command" >&2
  read -p "Continue (Y/n)?" -n 1 -r
  if [[ -n $REPLY ]]
  then
    echo "" >&2
  fi
  if [[ -z $REPLY ]] || [[ $REPLY =~ ^[Yy]$ ]]
  then
    bash -c "$command"
    exit $?
  fi
else
  bash -c "$command"
  exit $?
fi
