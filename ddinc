#!/bin/bash
#
# Copyright (C) 2021 Stonyx
# http://www.stonyx.com
#
# This script is free software. You can redistribute it and/or modify it under the terms of the GNU
# General Public License Version 3 (or at your option any later version) as published by The Free
# Software Foundation.
#
# This script is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without
# even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
#
# If you did not received a copy of the GNU General Public License along with this script see
# http://www.gnu.org/copyleft/gpl.html or write to The Free Software Foundation, 675 Mass Ave,
# Cambridge, MA 02139, USA.

# Create a function called to check if a needed command is available
function check_if_available()
{
  # Save the passed in variables
  local command="$1"

  # Check if the command is not available
  if ! command -v "$command" > /dev/null
  then
    echo "Command $command is required but is not available." >&2
    exit 1
  fi
}

# Create a function called to build the source portion of the command
function build_source_portion()
{
  # Save passed in variables
  input_files=("${!1}")
  local -i use_compression=$2

  # Declare local variables
  local command

  # Loop through the input files array and build the xdelta3 source portion of the command
  for i in "${!input_files[@]}"
  do
    # Check if this is the first element in the array
    if (( $i == 0 ))
    then
      # Check if compression is disabled/enabled and build the source portion for this full input
      # file
      if (( $use_compression == 0 ))
      then
        command="\"${input_files[$i]}\""
      else
        command="<(xz -d -c \"${input_files[$i]}\""
        command="$command; echo \$? > \"$output_file.exit_codes\")"
      fi
    else
      # Build the source portion for this incremental input file
      command="<(xdelta3 -d -c -s $command"

      # Check if compression is disabled/enabled and continue building the source portion
      if (( $use_compression == 0 ))
      then
        command="$command \"${input_files[$i]}\""
      else
        command="$command <(xz -d -c \"${input_files[$i]}\""
        command="$command; echo \$? > \"$output_file.exit_codes\")"
      fi

      # Finish building the source portion
      command="$command; echo \$? > \"$output_file.exit_codes\")"
    fi
  done

  # Return the source portion of the command
  echo $command
}

# Create a function called to build a full backup command
function build_full_backup_command()
{
  # Save passed in variables
  local backup_file="$1"
  local output_file="$2"
  local dd_options="$3"
  local use_compression="$4"
  local xz_options="$5"

  # Build the command for a full backup
  local command="dd if=\"$backup_file\"$dd_options"

  # Check if compression is enabled and continue building the command
  if (( $use_compression == 1 ))
  then
    command="$command | xz -z -c$xz_options"
  fi

  # Check if an output file was specified and finish building the command
  if [[ -n "$output_file" ]]
  then
    command="$command > \"$output_file\""
  fi

  # Return the command for a full backup
  echo $command
}

# Create a function called to build an incremental backup command
function build_incremental_backup_command()
{
  # Save passed in variables
  input_files=("${!1}")
  local backup_file="$2"
  local output_file="$3"
  local dd_options="$4"
  local xdelta_options="$5"
  local -i use_compression=$6
  local xz_options="$7"

  # Call the build_source_portion function to build the source portion of the command
  local command="$(build_source_portion input_files[@] $use_compression)"

  # Build the command for an incremental backup
  command="xdelta3 -e -c -s $command$xdelta_options <(dd if=\"$backup_file\"$dd_options"
  command="$command; echo \$? > \"$output_file.exit_codes\")"

  # Check if compression is enabled and continue building the command
  if (( $use_compression == 1 ))
  then
    command="$command | xz -z -c$xz_options"
  fi

  # Check if an output file was specified and finish building the command
  if [[ -n "$output_file" ]]
  then
    command="$command > \"$output_file\""
  fi

  # Return the command for an incremental backup
  echo $command
}

# Create a function called to build a full restore command
function build_full_restore_command()
{
  # Save passed in variables
  local restore_file="$1"
  local output_file="$2"
  local dd_options="$3"
  local -i use_compression=$4

  # Declare local variables
  local command

  # Check if compression is disabled/enabled
  if (( $use_compression == 0 ))
  then
    # Build the command for a full restore
    command="dd if=\"$restore_file\""
  else
    # Build the command for a full restore
    command="xz -d -c \"$restore_file\""

    # Check if an output file or dd options were specified and continue building the command
    if [[ -n "$output_file" || -n "$dd_options" ]]
    then
      command="$command | dd"
    fi
  fi

  # Check if an output file was specified and continue building the command
  if [[ -n "$output_file" ]]
  then
    command="$command of=\"$output_file\""
  fi

  # Finish building the command
  command="$command$dd_options"

  # Return the command for a full restore
  echo $command
}

# Create a function called to build an incremental restore command
function build_incremental_restore_command()
{
  # Save the passed in variables
  input_files=("${!1}")
  local restore_file="$2"
  local output_file="$3"
  local dd_options="$4"
  local -i use_compression=$5

  # Call the build_source_portion function to build the source portion of the command
  local command="$(build_source_portion input_files[@] $use_compression)"

  # Build the command for an incremental restore
  command="xdelta3 -d -c -s $command"

  # Check if compression is disabled/enabled and continue building the command
  if (( $use_compression == 0 ))
  then
    command="$command \"$restore_file\""
  else
    command="$command <(xz -d -c \"$restore_file\""
    command="$command; echo \$? > \"$output_file.exit_codes\")"
  fi

  # Check if an output file or dd options were specified and continue building the command
  if [[ -n "$output_file" || -n "$dd_options" ]]
  then
    command="$command | dd"
  fi

  # Check if an output file was specified and continue building the command
  if [[ -n "$output_file" ]]
  then
    command="$command of=\"$output_file\""
  fi

  # Finish building the command
  command="$command$dd_options"

  # Return the command for an incremental restore
  echo $command
}

# Create function called to run the command
function run_command()
{
  # Save the passed in variables
  local command="$1"
  local output_file="$2"

  # Declare needed variables
  local -a pipe_exit_codes
  local -i failed_commands=0

  # Check if process substitutions are being used in the command
  if [[ $command == *"<("*")"* ]]
  then
    # Create the exit codes named pipe
    mkfifo "$output_file.exit_codes"
  fi

  # Check if pipes are being used in the command
  if [[ $command == *"|"* ]]
  then
    # Run the command and save the pipe exit codes
    eval "$command;"'pipe_exit_codes=(${PIPESTATUS[@]})' &

    # Loop through the pipe exit codes and check if any of the commands failed
    for exit_code in "${pipe_exit_codes[@]}"
    do
      if (( exit_code == 1 ))
      then
        failed_commands=$((failed_commands + 1))
      fi
    done
  else
    # Run the command
    eval "$command"
  fi  

  # Check if process substitution is being used in the command
  if [[ $command == *"<("*")"* ]]
  then
    # Declare needed variables
    local -a process_sub_exit_codes

    # Read the process substitution exit codes from the exit codes named pipe
    readarray -t process_sub_exit_codes < "$output_file.exit_codes"

    # Loop through the process substitution exit codes and check if any of the commands failed
    for exit_code in "${process_sub_exit_codes[@]}"
    do
      if (( exit_code == 1 ))
      then
        failed_commands=$((failed_commands + 1))
      fi
    done
  fi

  # Return the number of failed commands
  return $failed_commands
}

# Declare all options variables
declare -a input_files
declare backup_file
declare restore_file
declare output_file
declare dd_options=" status=progress"
declare xdelta_options=" -T 0"
declare xz_options
declare -i use_compression=0
declare -i ask_for_confirmation=0
declare -i print_only=0
declare -i quiet_mode=0

# Get the options
while getopts "i:f:b:r:o:d:l:cx:apqh" option
do
  case $option in
    i)
      input_files+=("$OPTARG")
      ;;
    f)
      # Read the file paths into an array
      declare -a paths
      mapfile -t paths < "$OPTARG"

      # Get the dependees file path (without relying on dirname command)
      declare dependees_file_path
      if [[ "$OPTARG" != *"/"* ]]
      then
        dependees_file_path="."
      else
        dependees_file_path="${OPTARG%/*}"
      fi

      # Loop through the file paths
      for i in "${!paths[@]}"
      do
        # Check if the path is relative
        if [[ "${paths[$i]}" != "/"* ]]
        then
          # Prepend the dependees file path to the path
          paths[$i]="$dependees_file_path/${paths[$i]}"
        fi
      done

      # Append the file paths to the input files array
      input_files+=("${paths[@]}")
      ;;
    b)
      backup_file="$OPTARG"
      ;;
    r)
      restore_file="$OPTARG"
      ;;
    o)
      output_file="$OPTARG"
      ;;
    d)
      dd_options=" $OPTARG"
      ;;
    l)
      xdelta_options=" $OPTARG"
      ;;
    c)
      use_compression=1
      ;;
    x)
      xz_options=" $OPTARG"
      ;;
    a)
      ask_for_confirmation=1
      ;;
    p)
      print_only=1
      ;;
    q)
      quiet_mode=1
      ;;
    h)
      echo "Usage: ddinc [-i file] [-f file] (-b file_or_device | -r file) [-o file_or_device]" \
           "[-d dd_options] [-l xdelta3 options] [-c] [-x xz_options] [(-a | -p | -q)]" >&2
      echo >&2
      echo "-i    dependee input file (can be specified multiple times)" >&2
      echo "-f    file containing list of dependee input files (using absolute paths or paths" \
           "relative to this file) (can be specified multiple times)" >&2
      echo "-b    file or device to backup" >&2
      echo "-r    file to restore" >&2
      echo "-o    output file or device (uses stdout if not specified)" >&2
      echo "-d    string containing options passed to dd for reading in backup mode and writing" \
           "in restore mode (default is \"status=progress\"" >&2
      echo "-l    string containing options passed to xdelta3 for encoding" >&2
      echo "-c    use compression" >&2
      echo "-x    string containing options passed to xz for compression (default is \"-T 0\")" >&2
      echo "-a    ask for confirmation before running command" >&2
      echo "-p    print command that would be run without running it" >&2
      echo "-q    quietly run command without printing it" >&2
      echo "-h    show help" >&2
      echo
      echo "Backup examples" >&2
      echo "ddinc -i ../january/sda.dd.xz -i ../february/sda.dd.xdelta.xz" \
           "-i ../march/sda.dd.xdelta.xz -b /dev/sda -o sda.dd.xdelta.xz" >&2
      echo "ddinc -f sda.dd.dependees -b /dev/sda -o sda.dd.xdelta.xz" >&2
      echo
      echo "Restore examples" >&2
      echo "ddinc -i ../january/sda.dd.xz -i ../february/sda.dd.xdelta.xz" \
           "-i ../march/sda.dd.xdelta.xz -r sda.dd.xdelta.xz -o /dev/sda" >&2
      echo "ddinc -f sda.dd.dependees -r sda.dd.xdelta.xz -o /dev/sda" >&2

      exit 0
      ;;
  esac
done
shift $((OPTIND - 1))

# Check if the needed commands are available
check_if_available "dd"
check_if_available "xdelta3"
if (( $use_compression == 1 ))
then
  check_if_available "xz"
fi
check_if_available "mkfifo"

# Make sure a backup file or a restore file was specified and not both
if [[ -z "$backup_file" && -z "$restore_file" ]]
then
  echo "No backup file or restore file was specified.  See help (-h) for details." >&2
  exit 1
fi
if [[ -n "$backup_file" && -n "$restore_file" ]]
then
  echo "Both backup and restore file was specified.  See help (-h) for details." >&2
  exit 1
fi

# Make sure none or only one of the a, p, or q options was specified
if (( ($ask_for_confirmation == 1 && $print_only == 1) || \
  ($ask_for_confirmation == 1 && $quiet_mode == 1) || 
  ($print_only == 1 && $quiet_mode == 1) ))
then
  echo "Only one of the -a, -p, or -q options can be specified.  See help (-h) for details." >&2
  exit 1  
fi

# Make sure all input files exist and are not directories
for input in "${input_files[@]}"
do
  if [[ ! -e "$input" || -d "$input" ]]
  then
    echo "Input file $input does not exist." >&2
    exit 1
  fi
done

# Check if a backup file was specified
if [[ -n "$backup_file" ]]
then
  # Check if input files were specified and call the correct function to build the command
  if (( ${#input_files[@]} == 0 ))
  then
    command="$(build_full_backup_command "$backup_file" "$output_file" "$dd_options" \
      "$use_compression" "$xz_options")"
  else
    command="$(build_incremental_backup_command input_files[@] "$backup_file" "$output_file" \
      "$dd_options" "$xdelta_options" "$use_compression" "$xz_options")"
  fi
else
  # Check if input files were specified and call the correct function to build the command
  if (( ${#input_files[@]} == 0 ))
  then
    command="$(build_full_restore_command "$restore_file" "$output_file" "$dd_options" \
      "$use_compression")"
  else
    command="$(build_incremental_restore_command input_files[@] "$restore_file" "$output_file" \
      "$dd_options" "$use_compression")"
  fi
fi

# Check if print only is enabled
if (( $print_only == 1 ))
then
  # Print the command and exit
  echo "${command//; echo \$? > \"$output_file.exit_codes\"/}"
  exit 0
fi

# Check if quiet mode is enabled
if (( $quiet_mode == 1 ))
then
  # Run the command
  run_command "$command"

  # Return the number of failed commands
  exit $?
fi

# Check if ask for confirmation is disabled
if (( $ask_for_confirmation == 0 ))
then
  # Update the user
  echo "Running command: ${command//; echo \$? > \"$output_file.exit_codes\"/}" >&2

  # Run the command
  run_command "$command" "$output_file"

  # Return the number of failed commands
  exit $?
fi

# Update the user and ask for confirmation
echo "Command that will be run: ${command//; echo \$? > \"$output_file.exit_codes\"/}" >&2
read -p "Continue (Y/n)?" -n 1 -r

# Make things pretty
if [[ -n $REPLY ]]
then
  echo >&2
fi

# Check if the user replied with an enter or y
if [[ -z $REPLY || $REPLY =~ ^[Yy]$ ]]
then
  # Run the command
  run_command "$command" "$output_file"

  # Return the number of failed commands
  exit $?
fi

exit 255
